extend layout
block content


	style(type='text/css').
		html,body,#taxi-anim {
			width: 100%;
			height: 90%;
			margin: 0;
			padding: 0 20px 0 30px;
		}
		.marker, .coverage, .boundaries{
			position: absolute
		}
		.line{
			position: absolute;
		}

	.page-header
		h2 Roma Taxi
			small &nbsp animation of crawdad data

	#taxi-anim
	script.

		// parameters to control the animation
		var frameLimit = 5000;
		var frame = 1;
		
		var framePause = 800;
		var frameTransition = framePause-50;

		// parameters specific to Taxi SF dataset:
		// ... the earliest timestamp is 1211018404, 17-May-2008 10:00:04 
		// ... the latest timestamp is 1213089934, 6-June-2008 09:25:34
		// ... if the timestamp is GMT, then subtract 8 for SF

		var startTime = new Date(2000,1,1,12,0,0,0);
		var endTime = new Date(2000,1,1,12,0,15,0);

		// boundary points for our svg
		var boundary_points = [ {id : 'NW', x: 42.23961, y: 12.04925},
											  		{id : 'NE', x: 42.23961, y: 12.85368},
											  		{id : 'SE', x: 41.65899, y: 12.85368},
											  		{id : 'SW', x: 41.65899, y: 12.04925} ];

		// parameters for the graph
		var coverageRadius = 500;

		// container (and lookup table) for the data, i.e. GPS location of taxis
		var _graph_nodes = [];
		var _graph_edges = [];

		// create a map 
		var map = new google.maps.Map(d3.select("#taxi-anim").node(), {
			zoom: 14,
			center: new google.maps.LatLng(41.90759354,12.48991750),
			mapTypeId: google.maps.MapTypeId.ROADMAP
		});
		var styles = [ {stylers: [{ hue: '#e0dce8' }, { saturation: -60 }, { lightness: 60}] }];
		map.setOptions({styles: styles});

		// extend Google Maps' OverlayView class and create a new OverlayView object
		OverlayView.prototype = new google.maps.OverlayView();
		var overlay = new OverlayView();

		// bind the overlay to the map (thus calling overlay.onAdd)
		overlay.setMap(map);

		// start the chain



		var refreshID = setInterval(function(){
			console.log(frame);
			_updatePoints(overlay)

			startTime.setSeconds(startTime.getSeconds()+15);
			endTime.setSeconds(endTime.getSeconds()+15);
			if (++frame > frameLimit)
				clearInterval(refreshID);
			},framePause);
			


		function _updatePoints(overlay){
			d3.json('/taxi_roma/time?start=' + startTime.toTimeString().substr(0,2) + 'h' +
																									 startTime.toTimeString().substr(3,2) + 'm' +
																									 startTime.toTimeString().substr(6,2) + 's&end=' +
																									 endTime.toTimeString().substr(0,2) + 'h' + 
																									 endTime.toTimeString().substr(3,2) + 'm' + 
																									 endTime.toTimeString().substr(6,2) + 's', 
				function(error,data)
				{
					//console.log('Frame: ' + frame + ' start time: ' + startTime);
					_graph_nodes.length = 0;
					_graph_edges.length = 0;

					var _duplicate_check = [];
					data.forEach(function(datum){
						if (_duplicate_check.indexOf(datum.id) == -1)	
						{
							//if (datum.id == 352 || datum.id == 234 || datum.id == 37 || datum.id == 310 || datum.id == 322)
							{
							//console.log('Data: ' + '(' + datum.x + ',' + datum.y + ')');
								_graph_nodes.push({id: datum.id, x: Number(datum.x), y: Number(datum.y), neighbours: []});
								_duplicate_check.push(datum.id);
							}
						}
					});
					_graph_findNeighbours();

					graphs.length = 0;
					_graph_buildGraph();

					/*
					graphs.forEach(function(graph,i){
						var list_of_node = '';
						graph.forEach(function(node){
							list_of_node = list_of_node + ' ' + node.id;
						});
						//console.log('Graph ' + i + ':' + list_of_node);
					});
					*/
					
					graphs.forEach(function(graph,i){
						var graph_size = graph.length;
						var list_of_node = '';
						graph.forEach(function(node){
							list_of_node = list_of_node + ' ' + node.id;
							if (graph_size > 15)
								node.color = '#ff0000';
							else if (graph_size > 13)
								node.color = '#a81662';
							else if (graph_size > 9)
								node.color = '#c94b8c';
							else if (graph_size > 5)
								node.color = '#d870e6';
							else if (graph_size > 1)
								node.color = '#a370e6';
							else
								node.color = 'gray';
						});
						//console.log('Graph ' + i + ', size ' + graph.length + ' :' + list_of_node);
					});
					
					overlay.update();
			}); // end d3.json
		};


		function OverlayView(){

			var _projection;
			var _main_layer

			var x_padding = 62;
			var y_padding = -56;


			this.onAdd = function() {
				_main_layer  = d3.select(this.getPanes().overlayLayer).append('div').attr('id','main-layer');
				_main_svg	=	_main_layer.append('svg')
					.attr({
						'class':'boundaries'
					})
			};

			this.onRemove = function() {
				_main_layer.remove();
			};

			this.draw = function() {
				console.log("called draw");
				_projection = this.getProjection();
				this.update();
			};

			this.update = function(){
				console.log("called update");

				var _NW_point = find_pixel_position_of(boundary_points[0]);
				var _NW = {x : _NW_point.x, y : _NW_point.y};

				_main_svg
					.style('left', _NW.x + 'px')
					.style('top', _NW.y + 'px')
					.attr({
						'height': distance_in_pixels_between(boundary_points[0],boundary_points[3]),
						'width': distance_in_pixels_between(boundary_points[0],boundary_points[1])
						})					

				var lineFunction = d3.svg.line()
					.x(function(d) {return find_pixel_position_of(d).x - _NW.x;})
					.y(function(d) {return find_pixel_position_of(d).y - _NW.y;})
					.interpolate('linear');

				var connections = _main_svg.selectAll('path').data(_graph_edges,function(d){return d.id});
				var taxis = _main_svg.selectAll('circle').data(_graph_nodes,function(d){return d.id});

				connections.transition()
					.duration(frameTransition*0.8)
					.attr('d',function(d){return lineFunction(d.path);})
					.style('stroke',function(d){return d.origin.color})
				connections.enter().append('path')
					.attr('d',function(d){return lineFunction(d.path);})
					.style('stroke','blue')
					.classed('line',true)
					.style('stroke-width','0pt')
					.style('stroke',function(d){return d.origin.color})
					.transition()
						.delay(frameTransition*0.8)
						.duration(frameTransition*0.2)
						.style('stroke-width','0.5pt')
				connections.exit()
					.transition()
					.duration(frameTransition*0.25)
					.style('stroke-width','0pt')
					.remove();

				taxis.transition()
					.duration(frameTransition*0.8)
					.attr({
						'cx': function(d){return find_pixel_position_of(d).x - _NW.x},
						'cy': function(d){return find_pixel_position_of(d).y - _NW.y},
						'r':5,
						'fill': function(d){return d.color},
						'fill-opacity' : 1
					});
				taxis.enter().append('circle')
					.attr({
						'cx': function(d){return find_pixel_position_of(d).x - _NW.x},
						'cy': function(d){return find_pixel_position_of(d).y - _NW.y},
						'r':5,
						'fill': function(d){return d.color},
						'class': 'marker'
					})
					.style('fill-opacity',1e-6)
					.transition()
						.duration(frameTransition*0.8)
						.style('fill-opacity',1);
				taxis.exit()
					.transition()
					.duration(frameTransition*0.25)
					.style('fill-opacity',1e-6)
					.remove();

				var labels = _main_svg.selectAll('text').data(_graph_nodes,function(d){return d.id});
				labels.transition()
					.duration(frameTransition)
					.attr({
						'x': function(d){return find_pixel_position_of(d).x - _NW.x + 7},
						'y': function(d){return find_pixel_position_of(d).y - _NW.y + 5},
						'fill':'black'
					})
					.text(function(d){ return d.id });
				labels.enter().append('text')
					.attr({
						'x': function(d){return find_pixel_position_of(d).x - _NW.x + 7},
						'y': function(d){return find_pixel_position_of(d).y - _NW.y + 5},
						'fill':'black'
					})
					.style('fill-opacity',1e-6)
				.transition()
					.duration(frameTransition)
					.style('fill-opacity',1);
				labels.exit()
					.transition()
					.duration(frameTransition)
					.style('fill-opacity',1e-6)
					.remove();
			}; // end this.update

			

			function find_pixel_position_of(d){
				var LatLng = new google.maps.LatLng(d.x, d.y);
				var position = _projection.fromLatLngToDivPixel(LatLng);
				return position;
			}

			function distance_in_pixels_between(d1,d2){
				d1 = find_pixel_position_of(d1);
				d2 = find_pixel_position_of(d2);
				var distance = Math.sqrt((d2.x-d1.x)*(d2.x-d1.x)+(d2.y-d1.y)*(d2.y-d1.y));
				return distance;
			};


		}// end class 


		// Find the distance (in metres) between two coordinates on the map
		function convertLLtoM(lat1, lon1, lat2, lon2) {
			var R = 6378.137
			var a = 
				 0.5 - Math.cos((lat2 - lat1) * Math.PI / 180)/2 + 
				 Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
				 (1 - Math.cos((lon2 - lon1) * Math.PI / 180))/2;

			return 1000 * R * 2 * Math.asin(Math.sqrt(a));
		}

		// Convert a distance in metres into change in longitudinal coordinate
		// 
		// We are doing something very lazy here: at the equator, 1 longitudinal degree
		// is roughly 111,320 metres, so conversely, 1 metre is about 0.0000089831118
		function convertMtoLL(m) {
			return (m * 0.00000893831118);
		}


		// Graph-related codes

		var graphs = [];

		function _graph_findNeighbours()
		{
			for (var i = 0; i < _graph_nodes.length; i++)
			{
				for (var j = 0; j < _graph_nodes.length; j++)
				{
					if (i != j)
					{
						if (convertLLtoM(_graph_nodes[i].x,_graph_nodes[i].y,_graph_nodes[j].x,_graph_nodes[j].y) < coverageRadius)
						{
							if (_graph_nodes[i].neighbours.indexOf(_graph_nodes[j]) == -1)
							{
								_graph_nodes[i].neighbours.push(_graph_nodes[j]);
								_graph_edges.push({id: _graph_nodes[i].id + '-' + _graph_nodes[j].id,
																	 origin: _graph_nodes[i], 
																	 dest: _graph_nodes[j],
																	 path: [{x: _graph_nodes[i].x, y: _graph_nodes[i].y},
																	 				{x: _graph_nodes[j].x, y: _graph_nodes[j].y}]});
							}
						}
					}
				}
			}
		}

		function _graph_buildGraph()
		{
			var queue = [];
			var set = [];

			for (var i = 0; i < _graph_nodes.length; i++)
			{
				var current_graph = [];

				if (set.indexOf(_graph_nodes[i]) == -1)
				{
					queue.push(_graph_nodes[i]);
					set.push(_graph_nodes[i]);	
					current_graph.push(_graph_nodes[i]);
					while (queue.length > 0)
					{
						var q_head = queue.shift();
						q_head.neighbours.forEach(
							function(neighbour){
								if (set.indexOf(neighbour) == -1)
								{
									queue.push(neighbour);
									set.push(neighbour);
									current_graph.push(neighbour);
								}
							});
						if (queue.length == 0)
						{
							graphs.push(current_graph);
						}
					}
				}
			}
		}





