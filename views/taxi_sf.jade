extend layout

block additional_header

	script(src='/js/overlay.js', charset='utf-8')
	script(src='/js/taxiscript.js', charset='utf-8')
	script(src='/js/graph.js', charset='utf-8')
	link(rel='stylesheet', href='/css/taxi.css')
	

block content



	.page-header
		h2 San Fransisco
			small &nbsp animation of crawdad data

	.row#info-panel
		.col-md-3
			h3 Time
				span#info-time.large
		.col-md-3
		.col-md-3
		.col-md-1
		.col-md-2
			button.button#start-button Start
			button.button#stop-button(style='display:none') Stop
			button.button#reset-button Reset
	#taxi-anim
	script.

		// parameters to control the animation
		var frameLimit = 100;
		var frame = 1;
				
		var framePause = 2000;
		var frameTransition = framePause-50;


		// parameters specific to Taxi SF dataset:
		// ... the earliest timestamp is 1211018404, 17-May-2008 10:00:04 
		// ... the latest timestamp is 1213089934, 6-June-2008 09:25:34
		// ... if the timestamp is GMT, then subtract 8 for SF

		var time_increments = 45;
		var startTime = 1211018404;
		var endTime = startTime + time_increments;

		// boundary points for our svg
		var boundary_points = [ {id : 'NW', x: 37.99999, y: -122.56000},
											  		{id : 'NE', x: 37.99999, y: -122.00000},
											  		{id : 'SE', x: 37.20000, y: -122.00000},
											  		{id : 'SW', x: 37.20000, y: -122.56000} ];

		// parameters for the graph
		var coverageRadius = 300;

		// container (and lookup table) for the data, i.e. GPS location of taxis
		var _graph_nodes = [];
		var _graph_edges = [];

		// create a map 
		var map = new google.maps.Map(d3.select("#taxi-anim").node(), {
			zoom: 15,
			center: new google.maps.LatLng(37.7833,-122.4167),
			mapTypeId: google.maps.MapTypeId.ROADMAP
		});
		var styles = [ {stylers: [{ hue: '#e0dce8' }, { saturation: -60 }, { lightness: 60}] }];
		map.setOptions({styles: styles});

		// extend Google Maps' OverlayView class and create a new OverlayView object
		OverlayView.prototype = new google.maps.OverlayView();
		var overlay = new OverlayView();

		// bind the overlay to the map (thus calling overlay.onAdd)
		overlay.setMap(map);
		overlay.setTransitTime(frameTransition);
		// start the chain

		var currentTime = new Date(endTime*1000);
		d3.select('#info-time').text('  ' +	currentTime.toTimeString().substr(0,8));

		function mainLoop()
		{
			_updatePoints(overlay);

			startTime = endTime+1;
			endTime = endTime + time_increments;
			currentTime = new Date(endTime*1000);
			d3.select('#info-time').text('  ' +	currentTime.toTimeString().substr(0,8));
			if (++frame > frameLimit)
				clearInterval(refreshID);
		}	

		function _updatePoints(overlay){
			d3.json('/taxi_sf/time?start=' + startTime + '&end=' + endTime, function(error,data)
				{
					//console.log('Frame: ' + frame + ' start time: ' + startTime);
					_graph_nodes.length = 0;
					_graph_edges.length = 0;

					var _duplicate_check = [];
					data.forEach(function(datum){
						if (_duplicate_check.indexOf(datum.id) == -1)	
						{
							//if (datum.id == 352 || datum.id == 234 || datum.id == 37 || datum.id == 310 || datum.id == 322)
							{
							//console.log('Data: ' + '(' + datum.x + ',' + datum.y + ')');
								_graph_nodes.push({id: datum.id, x: Number(datum.x), y: Number(datum.y), neighbours: []});
								_duplicate_check.push(datum.id);
							}
						}
					});
					_graph_findNeighbours();

					graphs.length = 0;

					_graph_buildGraph();

					/*
					graphs.forEach(function(graph,i){
						var list_of_node = '';
						graph.forEach(function(node){
							list_of_node = list_of_node + ' ' + node.id;
						});
						//console.log('Graph ' + i + ':' + list_of_node);
					});
					*/
					
					graphs.forEach(function(graph,i){
						var graph_size = graph.length;
						var list_of_node = '';
						graph.forEach(function(node){
							list_of_node = list_of_node + ' ' + node.id;
							if (graph_size > 15)
								node.color = '#ff0000';
							else if (graph_size > 13)
								node.color = '#a81662';
							else if (graph_size > 9)
								node.color = '#c94b8c';
							else if (graph_size > 5)
								node.color = '#d870e6';
							else if (graph_size > 1)
								node.color = '#a370e6';
							else
								node.color = 'gray';
						});
						//console.log('Graph ' + i + ', size ' + graph.length + ' :' + list_of_node);
					});
					
					overlay.nodes = _graph_nodes;
					overlay.edges = _graph_edges;
					overlay.update();
			}); // end d3.json
		};



		// Find the distance (in metres) between two coordinates on the map
		function convertLLtoM(lat1, lon1, lat2, lon2) {
			var R = 6378.137
			var a = 
				 0.5 - Math.cos((lat2 - lat1) * Math.PI / 180)/2 + 
				 Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
				 (1 - Math.cos((lon2 - lon1) * Math.PI / 180))/2;

			return 1000 * R * 2 * Math.asin(Math.sqrt(a));
		}

		// Convert a distance in metres into change in longitudinal coordinate
		// 
		// We are doing something very lazy here: at the equator, 1 longitudinal degree
		// is roughly 111,320 metres, so conversely, 1 metre is about 0.0000089831118
		function convertMtoLL(m) {
			return (m * 0.00000893831118);
		}


		// Graph-related codes

		var graphs = [];

		function _graph_findNeighbours()
		{
			for (var i = 0; i < _graph_nodes.length; i++)
			{
				for (var j = 0; j < _graph_nodes.length; j++)
				{
					if (i != j)
					{
						if (convertLLtoM(_graph_nodes[i].x,_graph_nodes[i].y,_graph_nodes[j].x,_graph_nodes[j].y) < coverageRadius)
						{
							if (_graph_nodes[i].neighbours.indexOf(_graph_nodes[j]) == -1)
							{
								_graph_nodes[i].neighbours.push(_graph_nodes[j]);
								_graph_edges.push({id: _graph_nodes[i].id + '-' + _graph_nodes[j].id,
																	 origin: _graph_nodes[i], 
																	 dest: _graph_nodes[j],
																	 path: [{x: _graph_nodes[i].x, y: _graph_nodes[i].y},
																	 				{x: _graph_nodes[j].x, y: _graph_nodes[j].y}]});
							}
						}
					}
				}
			}
		}

		function _graph_buildGraph()
		{
			var queue = [];
			var set = [];

			for (var i = 0; i < _graph_nodes.length; i++)
			{
				var current_graph = [];

				if (set.indexOf(_graph_nodes[i]) == -1)
				{
					queue.push(_graph_nodes[i]);
					set.push(_graph_nodes[i]);	
					current_graph.push(_graph_nodes[i]);
					while (queue.length > 0)
					{
						var q_head = queue.shift();
						q_head.neighbours.forEach(
							function(neighbour){
								if (set.indexOf(neighbour) == -1)
								{
									queue.push(neighbour);
									set.push(neighbour);
									current_graph.push(neighbour);
								}
							});
						if (queue.length == 0)
						{
							graphs.push(current_graph);
						}
					}
				}
			}
		}





